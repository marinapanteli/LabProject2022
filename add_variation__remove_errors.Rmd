---
title: "Bit of playing around with mapping variants to transcripts"
author: "Mark Robinson"
date: "15/02/2022"
output:
  html_document: default
  pdf_document: default
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Load libraries

```{r libraries}
suppressPackageStartupMessages({
  library(VariantAnnotation)
  library(GenomicFeatures)
  library(BSgenome.Hsapiens.UCSC.hg38)
  library(Biostrings)
  library(ensembldb)
  library(Rsamtools)
  library(GenomicAlignments)
  library(stringr)
})
```

## Filtering VCF file to keep only high coverage variants

```{r vcf_filter}
(v <- readVcf("deepvariant_calls_pass.vcf.gz"))

# plot depth versus quality score (?)
plot(mcols(v)$QUAL,geno(v)[["DP"]][,1], pch=".", log="y")


keep <- geno(v)$DP[,1] > 10 &  mcols(v)$QUAL > 40 # keep only variants with depth > 10, quality>40
table(keep)
v <- v[keep]

```

## Focus on 1 gene

```{r import}

# z <- import("wtc11_with_cds_refined.gtf")
# z <- z[z$type=="CDS"]

x <- import("wtc11_corrected.gtf")
txdb <- makeTxDbFromGRanges(x)


x_ex <- x[x$type=="exon" & seqnames(x) != "chrM"]
g <- grepl("PB.749.", x_ex$transcript_id, 
           fixed = TRUE)
x_ex <- x_ex[g]
seqlevels(x_ex) <- seqlevels(x_ex)[-25]
x_ex


gr <- GRanges(seqnames(x_ex)[1],
              IRanges(start = min(start(x_ex)),
                      end = max(end(x_ex))),
              strand = strand(x_ex)[1]) 
gr 

# # fo <- findOverlaps(v, x_ex)
fop <- findOverlapPairs(rowRanges(v), x_ex)
fop

# read in BAM alignments only for this region
sbp <- ScanBamParam(which=gr,
                    what=scanBamWhat())
# sb <- scanBam("aln_s.bam", param=sbp)[[1]]

ga <- readGAlignments("aln_s.bam", param=sbp)
(variation_regs <- unique(first(fop))) #OOOOK

ss <- stackStringsFromGAlignments(ga, 
                                  variation_regs[1])# variation_regs[1] limited to one position of variation
table(ss) 
getSeq(Hsapiens, variation_regs[1]) #OOOOK the original nucleotide at the variation position


mcga <- mcols(ga) # get the metadata columns of the alignment reads
mcga$qname # get the alignments' names

# get regions of reads
rngs <- cigarRangesAlongReferenceSpace(mcga$cigar, 
                                       pos = mcga$pos,
                                       drop.empty.ranges = FALSE,
                                       N.regions.removed = FALSE,
                                       with.ops = TRUE,
                                       reduce.ranges = FALSE)
names(rngs) <- mcga$qname
rngs # ranges of all 95 bam alignment reads (in their segments)


rngs <- lapply(rngs, function(u) {
  nm <- names(u)
  names(u) <- NULL
  u[nm != "N"]
})
rngs <- IRangesList(rngs) # exclude N regions



# # get regions of reads
# rngs2 <- cigarRangesAlongReferenceSpace(mcga$cigar, 
#                                        pos = mcga$pos,
#                                        drop.empty.ranges = FALSE,
#                                        N.regions.removed = FALSE,
#                                        with.ops = TRUE,
#                                        reduce.ranges = FALSE)
# names(rngs2) <- mcga$qname
# rngs2

x_exs <- split(x_ex, x_ex$transcript_id)
x_exs

# intersect all reads with one transcript
# intersect(rngs, ranges(x_exs)[[1]])


# intersect all reads with all transcripts, form matrix
m <- matrix(0, ncol=length(variation_regs), 
            nrow = length(rngs),
            dimnames = list(names(rngs),
                            names(variation_regs)))

# populate the m matrix from the overlaps (clunky, but does the job) 
rngs_u <- unlist(rngs)
fo <- findOverlaps(rngs_u, ranges(variation_regs))
pop <- split(subjectHits(fo), names(rngs_u)[queryHits(fo)]) # which variations in a certain alignment read, and below notate with 0/1 if absent/present
for(i in 1:length(pop)) {
  m[names(pop)[i],unique(pop[[i]])] <- 1
}


# focus on one transcript
f <- first(fop)[second(fop)$transcript_id=="PB.749.1"]
(nm <- names(f)) #which of the 50 not necessarily unique variants are in transcript PB.749.1

# only take reads that overlap all variation of this transcript

w <- rowSums(m[,nm,drop=FALSE])==length(nm) 
(rds <- rownames(m)[w]) # which of the 95 alignment reads have all variations that transcript PB.749.1 has in general


ga_s <- ga[mcga$qname %in% rds] #subset for transcript of interest
z <- sapply(nm, function(u) {
  ss <- stackStringsFromGAlignments(ga_s,
                                    variation_regs[u])
  as.character(ss)
})
rownames(z) <- rownames(m)[w]
z # For the 5 variations (that many of the 50 are of transcript of interest), see the alternative alleles of the align. reads that overlap in the location of them all (all 5) 

#####
var_nucl <- vector()
orig_nucl <- vector()

for (r in 1:dim(z)[2]) {
    
    a1 <- colnames(z)[r]
    
    orig_nucl[r] <-strsplit( a1, split='[_/]')[[1]][2]
    
    var_nucl[r] <- strsplit( a1, split='[_/]')[[1]][3]
    
}


error_find <- matrix(1, ncol=dim(z)[2], 
            nrow = dim(z)[1])
# 1 means error, 0 means not error

for (t in 1:dim(z)[1]) {
  
  for (q in 1:dim(z)[2]) {
    
    if (gsub("[^[:alnum:][:space:]]","",(as.data.frame(z))[t,][[q]])==orig_nucl[q] || gsub("[^[:alnum:][:space:]]","",(as.data.frame(z))[t,][[q]])==var_nucl[q]) {
      
      error_find[t,q] <- 0
      
    }
  }
}



error_read <- rowSums(error_find)

error_read <- which(error_read != 0)

# If 0, the read is kept; else it's discarded
if (length(error_read)!=0) {
  
z <- z[-error_read,]  

}


#####


# table(ss)
getSeq(Hsapiens, variation_regs[nm]) # Also visible before the '/' of the nm string. It is the original nucleotides


table(apply(as.data.frame(z), 1, paste, collapse="__")) # The different combinations that are generated by the different reads

# sapply(x_exs, NROW)
# sapply(rngs, NROW)

# useful for the next part of the puzzle: getting the variation into the transcript sequences
# spot check
mapToTranscripts(x_exs[["PB.749.1"]], x_exs["PB.749.1"])
# positions where we need to insert variation
mapToTranscripts(variation_regs[nm], x_exs["PB.749.1"])


#fasta<-readDNAStringSet("wtc11_corrected.fasta")


# pc <- predictCoding(v, txdb, seqSource=Hsapiens)
# pc_s <- pc[pc$REFAA!=pc$VARAA]



####

####


```
